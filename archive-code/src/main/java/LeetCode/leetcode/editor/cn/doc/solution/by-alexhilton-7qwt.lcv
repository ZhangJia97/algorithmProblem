### 解题思路

一个数组的排列，就是各个元素**不断的交换位置后**得到的数组；另外重点理解**字典序**，位置靠左，的数如果大于靠右的数，那么后面的排列就是字典序大于前者，比如$[1, 3, 2]$在字典序中是大于$[1,2,3]$的。可以把数组的排列想像一个**特别大的数的数位**，左面是**高位**，往右则是**低位**，肯定是高位的数字变大会让整体数值更大。

下一个排列，肯定 是寻找 字典序更大的数，但下一个，又要求是更大的排列中的最小的一个，所以变动幅度要尽可能的小。

前面说了，让左边的数字变大，就能让整体排列变大，但又要尽可能的小，所以**需要找到一个能变大的最小数字**。
1. 从后向前查找第一个可变大的位置，也即找到第一个$j$，使，$[j] < [j+1]$，这样交换$[j]$和$[j+1]$后，就能得到一个更大的排列
2. 同时，还可以验证$[j+1, n-1]$这个序列是降序的
3. 但这不是最小解，因为$[j+1, n-1]$是降序的，所以这一范围内，肯定有比$[j+1]$更合适的解，从$[j+1, n-1]$范围内找到第一个大于$[j]$的元素，也即找到$k$，使$[j] < [k]$
4. 交换$[j]$和$[k]$
5. 但还不是最小的，$[j+1, n-1]$还是降序的，如果它是升序，会更小，所以要把$[j+1, n-1]$从小到大排序。但并不需要真正的排序，因为我们在上面的查找 过程中能验证$[j+1, n-1]$是降序的，所以只需要把它反转一下即可了。

### 代码

* java

```java
class Solution {
    public void nextPermutation(int[] nums) {
        final int n = nums.length;
        int j = n - 2;
        while (j >= 0 && nums[j] >= nums[j + 1]) {
            j--;
        }
        if (j >= 0) {
            int k = n - 1;
            while (k > j && nums[k] <= nums[j]) {
                k--;
            }
            swap(nums, j, k);
        }
        // reverse [j + 1, n - 1]
        for (int i = j + 1, k = n - 1; i < k; i++, k--) {
            swap(nums, i, k);
        }
    }

    private void swap(int[] nums, int i, int j) {
        if (i != j) {
            int tmp = nums[i];
            nums[i] = nums[j];
            nums[j] = tmp;
        }
    }
}
```

